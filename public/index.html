<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzled's Portfolio</title>
    <link rel="stylesheet" href="./style.css">
	
	<!-- Embed stuff -->
	<meta content="Puzzled's Portfolio" property="og:title" />
	<meta content="Compilation of all my projects and experience in programming" property="og:description" />
	<meta content="https://puzzl3d.dev/" property="og:url" />
	<meta content="https://tr.rbxcdn.com/30DAY-AvatarHeadshot-BA2EF2C4AD16F2BD8AC82FAA40C7E828-Png/150/150/AvatarHeadshot/Png" property="og:image" />
	<meta content="#C4281C" data-react-helmet="true" name="theme-color" />
</head>
<body>
    <header>
        <h1>Puzzled (@Puzzled3d)</h1>
        <nav>
            <ul>
                <li><a id="aboutme" href="./">About Me</a></li>
                <li><a id="experience" href="./Experience/">My Experience</a></li>
                <li><a id="discord" href="https://discordapp.com/users/857638850766962760">Discord</a></li>
				<li><a id="github" href="https://github.com/Puzzl3d3d">Github</a></li>
				<!-- <li><a id="github" href="https://flask.puzzl3d.dev/">Flask Projects</a></li> -->
            </ul>
        </nav>
    </header>
    <main>

        <h2>
            Hello! I'm <a href="https://www.roblox.com/users/66961502">Puzzled (@Puzzled3d)</a>
        </h2>

        <h1>
            About me
        </h1>

        <p>
            Over 3 years of Roblox LuaU experience<br>
			7 years of general programming experience<br>
            UK, GMT+0
        </p>

        <br>

        <h1>Code Snippets</h1>

        <p>
            This includes some of my code snippets of my recent projects. I like to keep my code organised and readable and structured.`
        </p>

        <br>

        <div class="code">
            <pre class="language-lua">--// Stat Profiler
--//--// Module for Datastore management as a wrapper for ProfileService.
--//--// Includes:
--//--//--|| Automatic attribute management
--//--//--|| Instant updates to profile
--//--//--|| Easy way to structure datastore

local StatProfiler = {}
StatProfiler.Connections = {}

--// Update profile with data. Adds to datastore if not already a stat.
function StatProfiler.SetStat(player: Player, profile: any, stat: string, value: any): any
	profile.Data[stat] = value
	if typeof(value) ~= "table" then
		player:SetAttribute(stat:gsub("/",""), value)
	end
	return value
end

--// Loads a stat from the datastore. Like getting a stat, except it will create a profile entry if it doesn't already exist.
function StatProfiler.LoadStat(player: Player, profile: any, stat: string, default: any?): any
	local value = StatProfiler.GetStat(player, profile, stat, default)
	if typeof(value) ~= "table" then
		player:SetAttribute(stat:gsub("/",""), value)
	end
	
	if not StatProfiler.Connections[player] then StatProfiler.Connections[player] = {} end
	
	table.insert(StatProfiler.Connections[player], player:GetAttributeChangedSignal(stat:gsub("/","")):Connect(function()
		--print("updating stat", stat, "to", player:GetAttribute(stat:gsub("/","")))
		StatProfiler.SetStat(player, profile, stat, player:GetAttribute(stat:gsub("/","")))
	end))
	
	profile.Data[stat] = value -- added bc i forgor
	
	return value
end

--// Increments a stat.
function StatProfiler.IncrementStat(player: Player, profile: any, stat: string, increment: number, default: number?): (any, boolean)
	local value, existed = StatProfiler.GetStat(player, profile, stat, default)
	profile.Data[stat] = (value) + increment
	if typeof(value) ~= "table" then
		player:SetAttribute(stat:gsub("/",""), profile.Data[stat])
	end
	
	if not StatProfiler.Connections[player] then StatProfiler.Connections[player] = {} end
	
	table.insert(StatProfiler.Connections[player], player:GetAttributeChangedSignal(stat:gsub("/","")):Connect(function()
		StatProfiler.SetStat(player, profile, stat, player:GetAttribute(stat:gsub("/","")))
	end))
	return profile.Data[stat], existed
end

--// Returns the value for a stat or default (if given)
function StatProfiler.GetStat(player: Player, profile: any, stat: string, default: any?): (any, boolean)
	local existed = profile.Data[stat]
	return existed or player:GetAttribute(stat:gsub("/","")) or default or 0, (not not existed)
end

--// Creates a leaderstat value for a stat. Also creates the leaderstats folder if it doesn't already exist.
function StatProfiler.CreateLeaderstat(player: Player, profile: any, stat: string, typeValue: string, default: any?): Instance
	local value, _existed = StatProfiler.GetStat(player, profile, stat, default)
	
	local leaderstats = player:FindFirstChild("leaderstats")
	if not leaderstats then
		leaderstats = Instance.new("Folder")
		leaderstats.Name = "leaderstats"
		leaderstats.Parent = player
	end
	
	local statValue = Instance.new(typeValue)
	statValue.Name = stat
	statValue.Value = value
	statValue.Parent = leaderstats
	
	statValue:GetPropertyChangedSignal("Value"):Connect(function()
		StatProfiler.SetStat(player, profile, stat, statValue.Value)
	end)
	player:GetAttributeChangedSignal(stat:gsub("/","")):Connect(function()
		statValue.Value = player:GetAttribute(stat:gsub("/",""))
	end)
	
	return statValue
end

return StatProfiler
</pre>

            <pre class="language-lua">local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Packages = ReplicatedStorage.Packages

local Knit = require(Packages.Knit)
local KeycodeImages = require(Packages.KeycodeImages)

local Camera = workspace.CurrentCamera

local InputController = Knit.CreateController {
	Name = "InputController";

	CurrentInteractions = {1};
	Interactions = {};
	CurrentConnections = {};
	MaxInteractUUID = 0;
}

function InputController:KnitInit()
    self._InteractService = Knit.GetService("InteractService")

    self.Player = Players.LocalPlayer

    local InteractGUI = self.Player:WaitForChild("PlayerGui"):WaitForChild("Interact").Frame
    local InteractFrame = InteractGUI.Frame
    InteractFrame.Parent = script

    InteractGUI.Parent.Enabled = true
    InteractGUI.Visible = true

    RunService.Heartbeat:Connect(function(deltaTime)
        local CurrentInteractions = self:GetCurrentInteractions()
        for Keycode,InteractionData in pairs(CurrentInteractions) do
            if InteractionData.RemoveCondition(unpack(InteractionData.Args)) then
                self:RemoveInteract(InteractionData.UUID)
                continue
            end

            local CurrentConnection = self.CurrentConnections[Keycode]

            if CurrentConnection and CurrentConnection.UUID == Keycode then return end
            if CurrentConnection then
                CurrentConnection.InputBegan:Disconnect()
                CurrentConnection.Frame:Destroy()
                self.CurrentConnections[Keycode] = nil
            end

            local Frame = InteractFrame:Clone()

            local ConnectionData = {
                InputBegan = UserInputService.InputBegan:Connect(function(inputObject)
                    if inputObject.KeyCode == Keycode then
                        self:Interact(InteractionData.UUID)
                    end
                end);
                Frame = Frame;
                UUID = InteractionData.UUID;
            }
            self.CurrentConnections[Keycode] = ConnectionData

            Frame.KeycodeImage.Image = "rbxassetid://"..tostring(KeycodeImages[Keycode] or KeycodeImages[Enum.KeyCode.Unknown] or 15664197440)
            Frame.InteractLabel.Text = InteractionData.Name
            Frame.Visible = not self.Player.Character:GetAttribute("IsInteracting")
            Frame.Parent = InteractGUI

            InteractionData.RemoveEvent.Event:Once(function()
                ConnectionData.InputBegan:Disconnect()
                Frame:Destroy()
                self.CurrentConnections[Keycode] = nil
            end)
        end
    end)

    -- Other interactions
    local ClimbInteraction
    local function HandleRope(Rope)
        local Collider = Rope:FindFirstChild("Collider")
        if not Collider then print(Rope,"has no collider") return end
		
        Collider.Touched:Connect(function(otherPart)
            if ClimbInteraction then return end
            if otherPart.Name ~= "Head" then return end
            local Character = self.Player.Character
            if not Character then return end
            if not otherPart:IsDescendantOf(Character) then return end

            ClimbInteraction = self:GetInteractionData(self:AddInteract(
                "Climb",
                Enum.KeyCode.Space,
                3,
                function(Collider, otherPart)
                    local collidingParts = Collider:GetTouchingParts()
                    if 
                        #collidingParts == 0 or
                        not table.find(collidingParts, otherPart) 
                    then 
                        return true 
                    end
                end,
                -- Args
                Collider,
                otherPart
            ))

            ClimbInteraction.RemoveEvent.Event:Once(function()
                ClimbInteraction = nil
            end)
        end)
    end
    for _,Rope in pairs(workspace.Ropes:GetChildren()) do
        HandleRope(Rope)
    end
    workspace.Ropes.ChildAdded:Connect(HandleRope)
end

function InputController:GetCurrentInteractions()
	local AllInteractions = {};
	for Key,InteractionData in pairs(self.Interactions) do
		if InteractionData.RemoveCondition(unpack(InteractionData.Args)) then
			self:RemoveInteract(InteractionData.UUID)
			continue
		end
		AllInteractions[InteractionData.KeyCode] = AllInteractions[InteractionData.KeyCode] or {}
		table.insert(AllInteractions[InteractionData.KeyCode], InteractionData)
	end
	local CurrentInteractions = {};
	for KeyCode,Interactions in pairs(AllInteractions) do
		local ThisInteraction
		if #Interactions == 1 then
			ThisInteraction = Interactions[1]
		else
			local HighestPriority = -1
			for _,InteractionData in pairs(Interactions) do
				if InteractionData.Priority >= HighestPriority then
					HighestPriority = InteractionData.Priority
					ThisInteraction = InteractionData
				end
			end
		end
		if not ThisInteraction then print("THERE IS NO",KeyCode,Interactions) continue end
		CurrentInteractions[KeyCode] = ThisInteraction
	end
	return CurrentInteractions
end
function InputController:GetInteractionData(UUID)
	for Key,InteractionData in pairs(self.Interactions) do
		if InteractionData.UUID == UUID then
			return InteractionData, Key
		end
	end
end
function InputController:AddInteract(Name, KeyCode, Priority, RemoveCondition, ...)
	local InteractionData = {
		Name = Name;
		KeyCode = KeyCode;
		Priority = Priority;
		Args = {...};
		UUID = self.MaxInteractUUID + 1;
		RemoveCondition = RemoveCondition;
		RemoveEvent = Instance.new("BindableEvent");
	}
	self.MaxInteractUUID += 1
	table.insert(self.Interactions, InteractionData)
	return InteractionData.UUID
end
function InputController:RemoveInteract(UUID)
	local InteractionData,Key = self:GetInteractionData(UUID)
	if not InteractionData or not Key then return end
	self.Interactions[Key] = nil
	local CurrentConnection = self.CurrentConnections[InteractionData.Keycode]
	if CurrentConnection and CurrentConnection.UUID == UUID then
		CurrentConnection.InputBegan:Disconnect()
		CurrentConnection.Frame:Destroy()
		self.CurrentConnections[InteractionData.Keycode] = nil
	end
	InteractionData.RemoveEvent:Fire()
end
function InputController:Interact(UUID)
	if self.Player.Character:GetAttribute("IsInteracting") then return end
	local InteractionData = self:GetInteractionData(UUID)
	if not InteractionData then return end
	local Name, Args = InteractionData.Name, InteractionData.Args

	self:RemoveInteract(UUID)

	self._InteractService:Interact(Name, unpack(Args))
end

return InputController</pre>
            
        </div>

        <br><br>

        <div class="code">
            <pre class="language-lua">local module = {}
local switch = {}

switch.__index = switch

module.__call = function(t, var): Switch
	local switchObject = {}
	
	switchObject.var = var
	
	setmetatable(switchObject, switch)
	
	return switchObject
end

function switch:case(value: any, callback: ()->(), ...): Switch
	if self.expired then return self end
	if self.var == value then
		self.returned = {callback(...)}
		self.expired = true
	end
	return self
end
function switch:otherwise(callback: ()->(), ...): Switch-- Cannot use name "else" because it is a reserved keyword
	if self.expired then return self end
	self.returned = {callback(...)}
	self.expired = true
	return self
end

-- Aliases
switch.other = switch.otherwise
switch.except = switch.otherwise
switch.unless = switch.otherwise

switch.match = switch.case

type case = (any, (any?)->(any?), any?) -> Switch
type otherwise = ((any?)->(any?), any?) -> Switch
export type Switch = {
	case: case,
	match: case,
	
	otherwise: otherwise,
	other: otherwise,
	except: otherwise,
	unless: otherwise	
}

return setmetatable(module, module)</pre>

			<pre class="language-lua">local HttpService = game:GetService("HttpService")
local SequenceProvider = game:GetService("KeyframeSequenceProvider")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Packages = ReplicatedStorage.Packages

local Knit = require(Packages.Knit)

local AnimationService = Knit.CreateService {
	Name = "AnimationService";
	Client = {
		StartAnim = Knit.CreateSignal();
		ExecuteFunction = Knit.CreateSignal();
	};
}

function AnimationService:KnitStart()
	print("AnimationService Started!")
end
function AnimationService:KnitInit()
	print("AnimationService Initialised!")

	Players.PlayerAdded:Connect(function(player)
		player.CharacterAdded:Connect(function(character)
			local Humanoid = character:WaitForChild("Humanoid")
			local Animator = Humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", Humanoid)
		end)
	end)
	for _,Enemy in pairs(workspace.Enemies:GetChildren()) do
		local Humanoid = Enemy:WaitForChild("Humanoid")
		local Animator = Humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", Humanoid)
	end

	self.LengthCache = {}
end

function AnimationService:AddAnimationModel(Character, Mesh, ParentPart)
	local Mesh = Mesh:Clone()
	Mesh.Anchored = false
	Mesh:PivotTo(ParentPart:GetPivot())
	local Motor6D = Instance.new("Motor6D")
	Motor6D.Part0 = ParentPart
	Motor6D.Part1 = Mesh
	Motor6D.C0 = Mesh:GetAttribute("C0") or CFrame.new(0,0,0)
	Motor6D.C1 = Mesh:GetAttribute("C1") or CFrame.new(0,0,0)
	Motor6D.Parent = Mesh
	Mesh.Parent = Character
	return Mesh
end
function AnimationService:LoadAnimation(Animator:Animator, AnimationId:string, Properties:{[string]:any})
	Properties = Properties or {}

	local Animation = Instance.new("Animation")
	Animation.AnimationId = AnimationId
	Animation.Parent = workspace
	
	local AnimTrack = Animator:LoadAnimation(Animation)
	for Property, Value in pairs(Properties) do
		local Success, Error = pcall(function()
			AnimTrack[Property] = Value
		end)
		if not Success then
			warn("AnimTrack has no property", Property,"| Attempted to set to",Value)
		end
	end

	return AnimTrack, Animation
end
function AnimationService:AnimateModel(Model:Model, AnimationId:string, Properties:{[string]:any})
	Properties = Properties or {}

	local AnimController = Model:FindFirstChildOfClass("AnimationController") -- Ironically also the name of the module lol
	if not AnimController then warn(Model,"has no AnimationController") return end
	local Animator = AnimController:FindFirstChildOfClass("Animator")
	if not Animator then warn(Model,">",AnimController,"has no Animator") return end

	local AnimTrack, Animation = self:LoadAnimation(Animator, AnimationId, Properties)

	AnimTrack:Play()
	return AnimTrack, Animation
end
function AnimationService:AnimateHumanoid(Character:Model, AnimationId:string, Properties:{[string]:any})
	Properties = Properties or {}
	
	local Humanoid = Character:FindFirstChildOfClass("Humanoid")
	if not Humanoid then warn(Character,"is not a Humanoid, attempting to animate as a Model") return self:AnimateModel(Character, AnimationId, Properties) end
	local Animator = Humanoid:FindFirstChildOfClass("Animator")
	if not Animator then warn(Character,">",Humanoid,"has no Animator") return end
	
	local AnimTrack, Animation = self:LoadAnimation(Animator, AnimationId, Properties)
	
	AnimTrack:Play()
	return AnimTrack, Animation
end
function AnimationService:GetAnimLength(AnimTrack, Timeout)
	local ID = AnimTrack.Animation.AnimationId
	local Length = self.LengthCache[ID]
	if not Length or Length == 0 then
		Timeout = Timeout or 1
		local Begin = os.clock()
		repeat
			Length = AnimTrack.Length
			task.wait()
		until Length ~= 0 or (os.clock() - Begin) >= Timeout
	end
	if Length ~= 0 then
		self.LengthCache[ID] = Length
	end
	return Length
end
function AnimationService:GetAnimMarkers(ID: string): {string?}
	local Markers = {}
	local KeyframeSequence: KeyframeSequence = SequenceProvider:GetKeyframeSequenceAsync(ID)
	local function Recurse(Parent)
		for _, Child in pairs(Parent:GetChildren()) do
			if (Child:IsA("KeyframeMarker")) then
				table.insert(Markers, Child)
			end
			if (#Child:GetChildren() > 0) then
				Recurse(Child)
			end
		end
	end
	Recurse(KeyframeSequence)

	return Markers
end
function AnimationService:Animate(...)
	local LongestLength = 0

	self:LockCamera()

	for _,AnimData:AnimData in pairs({...}) do
		local Model, ID, Properties, MarkerData = AnimData.Model, AnimData.ID, AnimData.Properties or {}, AnimData.MarkerData or {}
		local AnimTrack, Animation

		local Humanoid = Model:FindFirstChildOfClass("Humanoid")
		if Humanoid then
			AnimTrack, Animation = self:AnimateHumanoid(Model, ID, Properties)
		else
			AnimTrack, Animation = self:AnimateModel(Model, ID, Properties)
		end
		
		local Length = self:GetAnimLength(AnimTrack, 0.5)
		if Length == 0 then Length = 1 end
		if Length > LongestLength then
			LongestLength = Length
		end

		local MarkerConnections = {}
		local Markers = self:GetAnimMarkers(ID)

		local Sounds = Model:FindFirstChild("Sounds", true) or Instance.new("Folder")
		local Particles = Model:FindFirstChild("Particles", true) or Instance.new("Folder")

		for _,Sound in pairs(Sounds:GetChildren()) do
			if Sound.Name ~= "Start" then continue end
			if not Sound:IsA("Sound") then continue end

			Sound:Play()
		end
		for _,Emitter in pairs(Particles:GetChildren()) do
			if Emitter.Name ~= "Start" then continue end
			if not Emitter:IsA("ParticleEmitter") then continue end

			Emitter.Enabled = true
			task.delay(Emitter:GetAttribute("Length") or (Emitter:FindFirstChild("Length") and Emitter:FindFirstChild("Length").Value) or 1, function()
				Emitter.Enabled = false
			end)
		end

		for _,Marker in pairs(Markers) do
			Marker = Marker.Name
			table.insert(MarkerConnections, AnimTrack:GetMarkerReachedSignal(Marker):Connect(function(paramString)
				local Length = tonumber(paramString)
				if MarkerData[Marker] then
					MarkerData[Marker].Payload(Model, ID, Properties, MarkerData, Length)
					if not MarkerData[Marker].Continue then return end
				end
				for _,Sound in pairs(Sounds:GetChildren()) do
					if Sound.Name ~= Marker then continue end
					if not Sound:IsA("Sound") then continue end

					Sound:Play()
				end
				for _,Emitter in pairs(Particles:GetChildren()) do
					if Emitter.Name ~= Marker then continue end
					if not Emitter:IsA("ParticleEmitter") then continue end

					Emitter.Enabled = true
					task.delay(Length or Emitter:GetAttribute("Length") or (Emitter:FindFirstChild("Length") and Emitter:FindFirstChild("Length").Value) or 1, function()
						Emitter.Enabled = false
					end)
				end
			end))
		end

		AnimTrack:Play()

		AnimTrack.Stopped:Once(function()
			Animation:Destroy()
			for _, Connection in pairs(MarkerConnections) do
				if Connection and Connection.Connected then
					Connection:Disconnect()
				end
			end
		end)
	end

	self:UnlockCamera()

	return LongestLength
end

function AnimationService:ClientExecute(Player, FunctionName, ...)
	local CallbackEvent = Instance.new("RemoteEvent", workspace)
	self.Client.ExecuteFunction:Fire(Player, CallbackEvent, FunctionName, ...)
	local ReturnValues = {CallbackEvent.OnServerEvent:Wait()}
	table.remove(ReturnValues, 1)
	CallbackEvent:Destroy()
	return unpack(ReturnValues)
end

function AnimationService:AnimatePlayer(TargetPlayer:Player, PlayerData:AnimData, GlobalData:AnimData)
	-- Player Data is the animations played locally, GlobalData is the animation played to other clients
	GlobalData = GlobalData or PlayerData

	local LongestLength = 0
	for _, Player in pairs(Players:GetChildren()) do
		local Length = self:ClientExecute(Player, "Animate", unpack(if Player==TargetPlayer then PlayerData else GlobalData))
		if Length > LongestLength then
			LongestLength = Length
		end
	end
	return LongestLength
end

export type AnimData = {ID:string,Model:Model,Properties:{[any]:any},MarkerData:{[string]:{Payload:(Model,string,{[any]:any},table,number)->{},Continue:boolean}}}

return AnimationService</pre>
        </div>

        <br>

    </main>
    <footer>
        <a id="discord" href="https://discordapp.com/users/857638850766962760">Discord</a>
        <a id="discord" href="https://www.roblox.com/users/66961502">Roblox</a>
    </footer>

    <script>
        /* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism-okaidia&languages=lua&plugins=line-numbers */
/// <reference lib="WebWorker"/>

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
			? self // if in worker
			: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
var Prism = (function (_self) {

	// Private helper vars
	var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
	var uniqueId = 0;

	// The grammar object for plaintext
	var plainTextGrammar = {};


	var _ = {
		/**
		 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
		 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
		 * additional languages or plugins yourself.
		 *
		 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
		 *
		 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.manual = true;
		 * // add a new <script> to load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		manual: _self.Prism && _self.Prism.manual,
		/**
		 * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
		 * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
		 * own worker, you don't want it to do this.
		 *
		 * By setting this value to `true`, Prism will not add its own listeners to the worker.
		 *
		 * You obviously have to change this value before Prism executes. To do this, you can add an
		 * empty Prism object into the global scope before loading the Prism script like this:
		 *
		 * ```js
		 * window.Prism = window.Prism || {};
		 * Prism.disableWorkerMessageHandler = true;
		 * // Load Prism's script
		 * ```
		 *
		 * @default false
		 * @type {boolean}
		 * @memberof Prism
		 * @public
		 */
		disableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,

		/**
		 * A namespace for utility methods.
		 *
		 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
		 * change or disappear at any time.
		 *
		 * @namespace
		 * @memberof Prism
		 */
		util: {
			encode: function encode(tokens) {
				if (tokens instanceof Token) {
					return new Token(tokens.type, encode(tokens.content), tokens.alias);
				} else if (Array.isArray(tokens)) {
					return tokens.map(encode);
				} else {
					return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
				}
			},

			/**
			 * Returns the name of the type of the given value.
			 *
			 * @param {any} o
			 * @returns {string}
			 * @example
			 * type(null)      === 'Null'
			 * type(undefined) === 'Undefined'
			 * type(123)       === 'Number'
			 * type('foo')     === 'String'
			 * type(true)      === 'Boolean'
			 * type([1, 2])    === 'Array'
			 * type({})        === 'Object'
			 * type(String)    === 'Function'
			 * type(/abc+/)    === 'RegExp'
			 */
			type: function (o) {
				return Object.prototype.toString.call(o).slice(8, -1);
			},

			/**
			 * Returns a unique number for the given object. Later calls will still return the same number.
			 *
			 * @param {Object} obj
			 * @returns {number}
			 */
			objId: function (obj) {
				if (!obj['__id']) {
					Object.defineProperty(obj, '__id', { value: ++uniqueId });
				}
				return obj['__id'];
			},

			/**
			 * Creates a deep clone of the given object.
			 *
			 * The main intended use of this function is to clone language definitions.
			 *
			 * @param {T} o
			 * @param {Record<number, any>} [visited]
			 * @returns {T}
			 * @template T
			 */
			clone: function deepClone(o, visited) {
				visited = visited || {};

				var clone; var id;
				switch (_.util.type(o)) {
					case 'Object':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = /** @type {Record<string, any>} */ ({});
						visited[id] = clone;

						for (var key in o) {
							if (o.hasOwnProperty(key)) {
								clone[key] = deepClone(o[key], visited);
							}
						}

						return /** @type {any} */ (clone);

					case 'Array':
						id = _.util.objId(o);
						if (visited[id]) {
							return visited[id];
						}
						clone = [];
						visited[id] = clone;

						(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {
							clone[i] = deepClone(v, visited);
						});

						return /** @type {any} */ (clone);

					default:
						return o;
				}
			},

			/**
			 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
			 *
			 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
			 *
			 * @param {Element} element
			 * @returns {string}
			 */
			getLanguage: function (element) {
				while (element) {
					var m = lang.exec(element.className);
					if (m) {
						return m[1].toLowerCase();
					}
					element = element.parentElement;
				}
				return 'none';
			},

			/**
			 * Sets the Prism `language-xxxx` class of the given element.
			 *
			 * @param {Element} element
			 * @param {string} language
			 * @returns {void}
			 */
			setLanguage: function (element, language) {
				// remove all `language-xxxx` classes
				// (this might leave behind a leading space)
				element.className = element.className.replace(RegExp(lang, 'gi'), '');

				// add the new `language-xxxx` class
				// (using `classList` will automatically clean up spaces for us)
				element.classList.add('language-' + language);
			},

			/**
			 * Returns the script element that is currently executing.
			 *
			 * This does __not__ work for line script element.
			 *
			 * @returns {HTMLScriptElement | null}
			 */
			currentScript: function () {
				if (typeof document === 'undefined') {
					return null;
				}
				if ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {
					return /** @type {any} */ (document.currentScript);
				}

				// IE11 workaround
				// we'll get the src of the current script by parsing IE11's error stack trace
				// this will not work for inline scripts

				try {
					throw new Error();
				} catch (err) {
					// Get file src url from stack. Specifically works with the format of stack traces in IE.
					// A stack will look like this:
					//
					// Error
					//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)
					//    at Global code (http://localhost/components/prism-core.js:606:1)

					var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
					if (src) {
						var scripts = document.getElementsByTagName('script');
						for (var i in scripts) {
							if (scripts[i].src == src) {
								return scripts[i];
							}
						}
					}
					return null;
				}
			},

			/**
			 * Returns whether a given class is active for `element`.
			 *
			 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
			 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
			 * given class is just the given class with a `no-` prefix.
			 *
			 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
			 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
			 * ancestors have the given class or the negated version of it, then the default activation will be returned.
			 *
			 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
			 * version of it, the class is considered active.
			 *
			 * @param {Element} element
			 * @param {string} className
			 * @param {boolean} [defaultActivation=false]
			 * @returns {boolean}
			 */
			isActive: function (element, className, defaultActivation) {
				var no = 'no-' + className;

				while (element) {
					var classList = element.classList;
					if (classList.contains(className)) {
						return true;
					}
					if (classList.contains(no)) {
						return false;
					}
					element = element.parentElement;
				}
				return !!defaultActivation;
			}
		},

		/**
		 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
		 *
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		languages: {
			/**
			 * The grammar for plain, unformatted text.
			 */
			plain: plainTextGrammar,
			plaintext: plainTextGrammar,
			text: plainTextGrammar,
			txt: plainTextGrammar,

			/**
			 * Creates a deep copy of the language with the given id and appends the given tokens.
			 *
			 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
			 * will be overwritten at its original position.
			 *
			 * ## Best practices
			 *
			 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
			 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
			 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
			 *
			 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
			 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
			 *
			 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
			 * @param {Grammar} redef The new tokens to append.
			 * @returns {Grammar} The new language created.
			 * @public
			 * @example
			 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
			 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
			 *     // at its original position
			 *     'comment': { ... },
			 *     // CSS doesn't have a 'color' token, so this token will be appended
			 *     'color': /\b(?:red|green|blue)\b/
			 * });
			 */
			extend: function (id, redef) {
				var lang = _.util.clone(_.languages[id]);

				for (var key in redef) {
					lang[key] = redef[key];
				}

				return lang;
			},

			/**
			 * Inserts tokens _before_ another token in a language definition or any other grammar.
			 *
			 * ## Usage
			 *
			 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
			 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
			 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
			 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
			 * this:
			 *
			 * ```js
			 * Prism.languages.markup.style = {
			 *     // token
			 * };
			 * ```
			 *
			 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
			 * before existing tokens. For the CSS example above, you would use it like this:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'cdata', {
			 *     'style': {
			 *         // token
			 *     }
			 * });
			 * ```
			 *
			 * ## Special cases
			 *
			 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
			 * will be ignored.
			 *
			 * This behavior can be used to insert tokens after `before`:
			 *
			 * ```js
			 * Prism.languages.insertBefore('markup', 'comment', {
			 *     'comment': Prism.languages.markup.comment,
			 *     // tokens after 'comment'
			 * });
			 * ```
			 *
			 * ## Limitations
			 *
			 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
			 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
			 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
			 * deleting properties which is necessary to insert at arbitrary positions.
			 *
			 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
			 * Instead, it will create a new object and replace all references to the target object with the new one. This
			 * can be done without temporarily deleting properties, so the iteration order is well-defined.
			 *
			 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
			 * you hold the target object in a variable, then the value of the variable will not change.
			 *
			 * ```js
			 * var oldMarkup = Prism.languages.markup;
			 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
			 *
			 * assert(oldMarkup !== Prism.languages.markup);
			 * assert(newMarkup === Prism.languages.markup);
			 * ```
			 *
			 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
			 * object to be modified.
			 * @param {string} before The key to insert before.
			 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
			 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
			 * object to be modified.
			 *
			 * Defaults to `Prism.languages`.
			 * @returns {Grammar} The new grammar object.
			 * @public
			 */
			insertBefore: function (inside, before, insert, root) {
				root = root || /** @type {any} */ (_.languages);
				var grammar = root[inside];
				/** @type {Grammar} */
				var ret = {};

				for (var token in grammar) {
					if (grammar.hasOwnProperty(token)) {

						if (token == before) {
							for (var newToken in insert) {
								if (insert.hasOwnProperty(newToken)) {
									ret[newToken] = insert[newToken];
								}
							}
						}

						// Do not insert token which also occur in insert. See #1525
						if (!insert.hasOwnProperty(token)) {
							ret[token] = grammar[token];
						}
					}
				}

				var old = root[inside];
				root[inside] = ret;

				// Update references in other language definitions
				_.languages.DFS(_.languages, function (key, value) {
					if (value === old && key != inside) {
						this[key] = ret;
					}
				});

				return ret;
			},

			// Traverse a language definition with Depth First Search
			DFS: function DFS(o, callback, type, visited) {
				visited = visited || {};

				var objId = _.util.objId;

				for (var i in o) {
					if (o.hasOwnProperty(i)) {
						callback.call(o, i, o[i], type || i);

						var property = o[i];
						var propertyType = _.util.type(property);

						if (propertyType === 'Object' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, null, visited);
						} else if (propertyType === 'Array' && !visited[objId(property)]) {
							visited[objId(property)] = true;
							DFS(property, callback, i, visited);
						}
					}
				}
			}
		},

		plugins: {},

		/**
		 * This is the most high-level function in Prism’s API.
		 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
		 * each one of them.
		 *
		 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
		 *
		 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
		 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
		 * @memberof Prism
		 * @public
		 */
		highlightAll: function (async, callback) {
			_.highlightAllUnder(document, async, callback);
		},

		/**
		 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
		 * {@link Prism.highlightElement} on each one of them.
		 *
		 * The following hooks will be run:
		 * 1. `before-highlightall`
		 * 2. `before-all-elements-highlight`
		 * 3. All hooks of {@link Prism.highlightElement} for each element.
		 *
		 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
		 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
		 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
		 * @memberof Prism
		 * @public
		 */
		highlightAllUnder: function (container, async, callback) {
			var env = {
				callback: callback,
				container: container,
				selector: 'pre[class*="language-"], [class*="language-"] pre, pre[class*="lang-"], [class*="lang-"] pre'
			};

			_.hooks.run('before-highlightall', env);

			env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));

			_.hooks.run('before-all-elements-highlight', env);

			for (var i = 0, element; (element = env.elements[i++]);) {
				_.highlightElement(element, async === true, env.callback);
			}
		},

		/**
		 * Highlights the code inside a single element.
		 *
		 * The following hooks will be run:
		 * 1. `before-sanity-check`
		 * 2. `before-highlight`
		 * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
		 * 4. `before-insert`
		 * 5. `after-highlight`
		 * 6. `complete`
		 *
		 * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
		 * the element's language.
		 *
		 * @param {Element} element The element containing the code.
		 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
		 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
		 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
		 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
		 *
		 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
		 * asynchronous highlighting to work. You can build your own bundle on the
		 * [Download page](https://prismjs.com/download.html).
		 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
		 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
		 * @memberof Prism
		 * @public
		 */
		highlightElement: function (element, async, callback) {
			// Find language
			var language = _.util.getLanguage(element);
			var grammar = _.languages[language];

			// Set language on the element, if not present
			_.util.setLanguage(element, language);

			// Set language on the parent, for styling
			var parent = element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre') {
				_.util.setLanguage(parent, language);
			}

			var code = element.textContent;

			var env = {
				element: element,
				language: language,
				grammar: grammar,
				code: code
			};

			function insertHighlightedCode(highlightedCode) {
				env.highlightedCode = highlightedCode;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
			}

			_.hooks.run('before-sanity-check', env);

			// plugins may change/add the parent/element
			parent = env.element.parentElement;
			if (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {
				parent.setAttribute('tabindex', '0');
			}

			if (!env.code) {
				_.hooks.run('complete', env);
				callback && callback.call(env.element);
				return;
			}

			_.hooks.run('before-highlight', env);

			if (!env.grammar) {
				insertHighlightedCode(_.util.encode(env.code));
				return;
			}

			if (async && _self.Worker) {
				var worker = new Worker(_.filename);

				worker.onmessage = function (evt) {
					insertHighlightedCode(evt.data);
				};

				worker.postMessage(JSON.stringify({
					language: env.language,
					code: env.code,
					immediateClose: true
				}));
			} else {
				insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
			}
		},

		/**
		 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
		 * and the language definitions to use, and returns a string with the HTML produced.
		 *
		 * The following hooks will be run:
		 * 1. `before-tokenize`
		 * 2. `after-tokenize`
		 * 3. `wrap`: On each {@link Token}.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @param {string} language The name of the language definition passed to `grammar`.
		 * @returns {string} The highlighted HTML.
		 * @memberof Prism
		 * @public
		 * @example
		 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
		 */
		highlight: function (text, grammar, language) {
			var env = {
				code: text,
				grammar: grammar,
				language: language
			};
			_.hooks.run('before-tokenize', env);
			if (!env.grammar) {
				throw new Error('The language "' + env.language + '" has no grammar.');
			}
			env.tokens = _.tokenize(env.code, env.grammar);
			_.hooks.run('after-tokenize', env);
			return Token.stringify(_.util.encode(env.tokens), env.language);
		},

		/**
		 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
		 * and the language definitions to use, and returns an array with the tokenized code.
		 *
		 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
		 *
		 * This method could be useful in other contexts as well, as a very crude parser.
		 *
		 * @param {string} text A string with the code to be highlighted.
		 * @param {Grammar} grammar An object containing the tokens to use.
		 *
		 * Usually a language definition like `Prism.languages.markup`.
		 * @returns {TokenStream} An array of strings and tokens, a token stream.
		 * @memberof Prism
		 * @public
		 * @example
		 * let code = `var foo = 0;`;
		 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
		 * tokens.forEach(token => {
		 *     if (token instanceof Prism.Token && token.type === 'number') {
		 *         console.log(`Found numeric literal: ${token.content}`);
		 *     }
		 * });
		 */
		tokenize: function (text, grammar) {
			var rest = grammar.rest;
			if (rest) {
				for (var token in rest) {
					grammar[token] = rest[token];
				}

				delete grammar.rest;
			}

			var tokenList = new LinkedList();
			addAfter(tokenList, tokenList.head, text);

			matchGrammar(text, tokenList, grammar, tokenList.head, 0);

			return toArray(tokenList);
		},

		/**
		 * @namespace
		 * @memberof Prism
		 * @public
		 */
		hooks: {
			all: {},

			/**
			 * Adds the given callback to the list of callbacks for the given hook.
			 *
			 * The callback will be invoked when the hook it is registered for is run.
			 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
			 *
			 * One callback function can be registered to multiple hooks and the same hook multiple times.
			 *
			 * @param {string} name The name of the hook.
			 * @param {HookCallback} callback The callback function which is given environment variables.
			 * @public
			 */
			add: function (name, callback) {
				var hooks = _.hooks.all;

				hooks[name] = hooks[name] || [];

				hooks[name].push(callback);
			},

			/**
			 * Runs a hook invoking all registered callbacks with the given environment variables.
			 *
			 * Callbacks will be invoked synchronously and in the order in which they were registered.
			 *
			 * @param {string} name The name of the hook.
			 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
			 * @public
			 */
			run: function (name, env) {
				var callbacks = _.hooks.all[name];

				if (!callbacks || !callbacks.length) {
					return;
				}

				for (var i = 0, callback; (callback = callbacks[i++]);) {
					callback(env);
				}
			}
		},

		Token: Token
	};
	_self.Prism = _;


	// Typescript note:
	// The following can be used to import the Token type in JSDoc:
	//
	//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

	/**
	 * Creates a new token.
	 *
	 * @param {string} type See {@link Token#type type}
	 * @param {string | TokenStream} content See {@link Token#content content}
	 * @param {string|string[]} [alias] The alias(es) of the token.
	 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
	 * @class
	 * @global
	 * @public
	 */
	function Token(type, content, alias, matchedStr) {
		/**
		 * The type of the token.
		 *
		 * This is usually the key of a pattern in a {@link Grammar}.
		 *
		 * @type {string}
		 * @see GrammarToken
		 * @public
		 */
		this.type = type;
		/**
		 * The strings or tokens contained by this token.
		 *
		 * This will be a token stream if the pattern matched also defined an `inside` grammar.
		 *
		 * @type {string | TokenStream}
		 * @public
		 */
		this.content = content;
		/**
		 * The alias(es) of the token.
		 *
		 * @type {string|string[]}
		 * @see GrammarToken
		 * @public
		 */
		this.alias = alias;
		// Copy of the full string this token was created from
		this.length = (matchedStr || '').length | 0;
	}

	/**
	 * A token stream is an array of strings and {@link Token Token} objects.
	 *
	 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
	 * them.
	 *
	 * 1. No adjacent strings.
	 * 2. No empty strings.
	 *
	 *    The only exception here is the token stream that only contains the empty string and nothing else.
	 *
	 * @typedef {Array<string | Token>} TokenStream
	 * @global
	 * @public
	 */

	/**
	 * Converts the given token or token stream to an HTML representation.
	 *
	 * The following hooks will be run:
	 * 1. `wrap`: On each {@link Token}.
	 *
	 * @param {string | Token | TokenStream} o The token or token stream to be converted.
	 * @param {string} language The name of current language.
	 * @returns {string} The HTML representation of the token or token stream.
	 * @memberof Token
	 * @static
	 */
	Token.stringify = function stringify(o, language) {
		if (typeof o == 'string') {
			return o;
		}
		if (Array.isArray(o)) {
			var s = '';
			o.forEach(function (e) {
				s += stringify(e, language);
			});
			return s;
		}

		var env = {
			type: o.type,
			content: stringify(o.content, language),
			tag: 'span',
			classes: ['token', o.type],
			attributes: {},
			language: language
		};

		var aliases = o.alias;
		if (aliases) {
			if (Array.isArray(aliases)) {
				Array.prototype.push.apply(env.classes, aliases);
			} else {
				env.classes.push(aliases);
			}
		}

		_.hooks.run('wrap', env);

		var attributes = '';
		for (var name in env.attributes) {
			attributes += ' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
		}

		return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + attributes + '>' + env.content + '</' + env.tag + '>';
	};

	/**
	 * @param {RegExp} pattern
	 * @param {number} pos
	 * @param {string} text
	 * @param {boolean} lookbehind
	 * @returns {RegExpExecArray | null}
	 */
	function matchPattern(pattern, pos, text, lookbehind) {
		pattern.lastIndex = pos;
		var match = pattern.exec(text);
		if (match && lookbehind && match[1]) {
			// change the match to remove the text matched by the Prism lookbehind group
			var lookbehindLength = match[1].length;
			match.index += lookbehindLength;
			match[0] = match[0].slice(lookbehindLength);
		}
		return match;
	}

	/**
	 * @param {string} text
	 * @param {LinkedList<string | Token>} tokenList
	 * @param {any} grammar
	 * @param {LinkedListNode<string | Token>} startNode
	 * @param {number} startPos
	 * @param {RematchOptions} [rematch]
	 * @returns {void}
	 * @private
	 *
	 * @typedef RematchOptions
	 * @property {string} cause
	 * @property {number} reach
	 */
	function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
		for (var token in grammar) {
			if (!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = Array.isArray(patterns) ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				if (rematch && rematch.cause == token + ',' + j) {
					return;
				}

				var patternObj = patterns[j];
				var inside = patternObj.inside;
				var lookbehind = !!patternObj.lookbehind;
				var greedy = !!patternObj.greedy;
				var alias = patternObj.alias;

				if (greedy && !patternObj.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
					patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
				}

				/** @type {RegExp} */
				var pattern = patternObj.pattern || patternObj;

				for ( // iterate the token list and keep track of the current token/string position
					var currentNode = startNode.next, pos = startPos;
					currentNode !== tokenList.tail;
					pos += currentNode.value.length, currentNode = currentNode.next
				) {

					if (rematch && pos >= rematch.reach) {
						break;
					}

					var str = currentNode.value;

					if (tokenList.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						return;
					}

					if (str instanceof Token) {
						continue;
					}

					var removeCount = 1; // this is the to parameter of removeBetween
					var match;

					if (greedy) {
						match = matchPattern(pattern, pos, text, lookbehind);
						if (!match || match.index >= text.length) {
							break;
						}

						var from = match.index;
						var to = match.index + match[0].length;
						var p = pos;

						// find the node that contains the match
						p += currentNode.value.length;
						while (from >= p) {
							currentNode = currentNode.next;
							p += currentNode.value.length;
						}
						// adjust pos (and p)
						p -= currentNode.value.length;
						pos = p;

						// the current node is a Token, then the match starts inside another Token, which is invalid
						if (currentNode.value instanceof Token) {
							continue;
						}

						// find the last node which is affected by this match
						for (
							var k = currentNode;
							k !== tokenList.tail && (p < to || typeof k.value === 'string');
							k = k.next
						) {
							removeCount++;
							p += k.value.length;
						}
						removeCount--;

						// replace with the new match
						str = text.slice(pos, p);
						match.index -= pos;
					} else {
						match = matchPattern(pattern, 0, str, lookbehind);
						if (!match) {
							continue;
						}
					}

					// eslint-disable-next-line no-redeclare
					var from = match.index;
					var matchStr = match[0];
					var before = str.slice(0, from);
					var after = str.slice(from + matchStr.length);

					var reach = pos + str.length;
					if (rematch && reach > rematch.reach) {
						rematch.reach = reach;
					}

					var removeFrom = currentNode.prev;

					if (before) {
						removeFrom = addAfter(tokenList, removeFrom, before);
						pos += before.length;
					}

					removeRange(tokenList, removeFrom, removeCount);

					var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);
					currentNode = addAfter(tokenList, removeFrom, wrapped);

					if (after) {
						addAfter(tokenList, currentNode, after);
					}

					if (removeCount > 1) {
						// at least one Token object was removed, so we have to do some rematching
						// this can only happen if the current pattern is greedy

						/** @type {RematchOptions} */
						var nestedRematch = {
							cause: token + ',' + j,
							reach: reach
						};
						matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);

						// the reach might have been extended because of the rematching
						if (rematch && nestedRematch.reach > rematch.reach) {
							rematch.reach = nestedRematch.reach;
						}
					}
				}
			}
		}
	}

	/**
	 * @typedef LinkedListNode
	 * @property {T} value
	 * @property {LinkedListNode<T> | null} prev The previous node.
	 * @property {LinkedListNode<T> | null} next The next node.
	 * @template T
	 * @private
	 */

	/**
	 * @template T
	 * @private
	 */
	function LinkedList() {
		/** @type {LinkedListNode<T>} */
		var head = { value: null, prev: null, next: null };
		/** @type {LinkedListNode<T>} */
		var tail = { value: null, prev: head, next: null };
		head.next = tail;

		/** @type {LinkedListNode<T>} */
		this.head = head;
		/** @type {LinkedListNode<T>} */
		this.tail = tail;
		this.length = 0;
	}

	/**
	 * Adds a new node with the given value to the list.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {T} value
	 * @returns {LinkedListNode<T>} The added node.
	 * @template T
	 */
	function addAfter(list, node, value) {
		// assumes that node != list.tail && values.length >= 0
		var next = node.next;

		var newNode = { value: value, prev: node, next: next };
		node.next = newNode;
		next.prev = newNode;
		list.length++;

		return newNode;
	}
	/**
	 * Removes `count` nodes after the given node. The given node will not be removed.
	 *
	 * @param {LinkedList<T>} list
	 * @param {LinkedListNode<T>} node
	 * @param {number} count
	 * @template T
	 */
	function removeRange(list, node, count) {
		var next = node.next;
		for (var i = 0; i < count && next !== list.tail; i++) {
			next = next.next;
		}
		node.next = next;
		next.prev = node;
		list.length -= i;
	}
	/**
	 * @param {LinkedList<T>} list
	 * @returns {T[]}
	 * @template T
	 */
	function toArray(list) {
		var array = [];
		var node = list.head.next;
		while (node !== list.tail) {
			array.push(node.value);
			node = node.next;
		}
		return array;
	}


	if (!_self.document) {
		if (!_self.addEventListener) {
			// in Node.js
			return _;
		}

		if (!_.disableWorkerMessageHandler) {
			// In worker
			_self.addEventListener('message', function (evt) {
				var message = JSON.parse(evt.data);
				var lang = message.language;
				var code = message.code;
				var immediateClose = message.immediateClose;

				_self.postMessage(_.highlight(code, _.languages[lang], lang));
				if (immediateClose) {
					_self.close();
				}
			}, false);
		}

		return _;
	}

	// Get current script and highlight
	var script = _.util.currentScript();

	if (script) {
		_.filename = script.src;

		if (script.hasAttribute('data-manual')) {
			_.manual = true;
		}
	}

	function highlightAutomaticallyCallback() {
		if (!_.manual) {
			_.highlightAll();
		}
	}

	if (!_.manual) {
		// If the document state is "loading", then we'll use DOMContentLoaded.
		// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the
		// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they
		// might take longer one animation frame to execute which can create a race condition where only some plugins have
		// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.
		// See https://github.com/PrismJS/prism/issues/2102
		var readyState = document.readyState;
		if (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {
			document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
		} else {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(highlightAutomaticallyCallback);
			} else {
				window.setTimeout(highlightAutomaticallyCallback, 16);
			}
		}
	}

	return _;

}(_self));

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}

// some additional documentation/types

/**
 * The expansion of a simple `RegExp` literal to support additional properties.
 *
 * @typedef GrammarToken
 * @property {RegExp} pattern The regular expression of the token.
 * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)
 * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.
 * @property {boolean} [greedy=false] Whether the token is greedy.
 * @property {string|string[]} [alias] An optional alias or list of aliases.
 * @property {Grammar} [inside] The nested grammar of this token.
 *
 * The `inside` grammar will be used to tokenize the text value of each token of this kind.
 *
 * This can be used to make nested and even recursive language definitions.
 *
 * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into
 * each another.
 * @global
 * @public
 */

/**
 * @typedef Grammar
 * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}
 * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.
 * @global
 * @public
 */

/**
 * A function which will invoked after an element was successfully highlighted.
 *
 * @callback HighlightCallback
 * @param {Element} element The element successfully highlighted.
 * @returns {void}
 * @global
 * @public
 */

/**
 * @callback HookCallback
 * @param {Object<string, any>} env The environment variables of the hook.
 * @returns {void}
 * @global
 * @public
 */
;
Prism.languages.lua = {
	'comment': /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
	// \z may be used to skip the following space
	'string': {
		pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
		greedy: true
	},
	'number': /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
	'keyword': /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|nil|not|or|repeat|return|then|true|until|while)\b/,
	'function': /(?!\d)\w+(?=\s*(?:[({]))/,
	'operator': [
		/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?|(?:local)/,
		{
			// Match ".." but don't break "..."
			pattern: /(^|[^.])\.\.(?!\.)/,
			lookbehind: true
		}
	],
	'punctuation': /[\[\](){},;]|\.+|:+/
};

(function () {

	if (typeof Prism === 'undefined' || typeof document === 'undefined') {
		return;
	}

	/**
	 * Plugin name which is used as a class name for <pre> which is activating the plugin
	 *
	 * @type {string}
	 */
	var PLUGIN_NAME = 'line-numbers';

	/**
	 * Regular expression used for determining line breaks
	 *
	 * @type {RegExp}
	 */
	var NEW_LINE_EXP = /\n(?!$)/g;


	/**
	 * Global exports
	 */
	var config = Prism.plugins.lineNumbers = {
		/**
		 * Get node for provided line number
		 *
		 * @param {Element} element pre element
		 * @param {number} number line number
		 * @returns {Element|undefined}
		 */
		getLine: function (element, number) {
			if (element.tagName !== 'PRE' || !element.classList.contains(PLUGIN_NAME)) {
				return;
			}

			var lineNumberRows = element.querySelector('.line-numbers-rows');
			if (!lineNumberRows) {
				return;
			}
			var lineNumberStart = parseInt(element.getAttribute('data-start'), 10) || 1;
			var lineNumberEnd = lineNumberStart + (lineNumberRows.children.length - 1);

			if (number < lineNumberStart) {
				number = lineNumberStart;
			}
			if (number > lineNumberEnd) {
				number = lineNumberEnd;
			}

			var lineIndex = number - lineNumberStart;

			return lineNumberRows.children[lineIndex];
		},

		/**
		 * Resizes the line numbers of the given element.
		 *
		 * This function will not add line numbers. It will only resize existing ones.
		 *
		 * @param {HTMLElement} element A `<pre>` element with line numbers.
		 * @returns {void}
		 */
		resize: function (element) {
			resizeElements([element]);
		},

		/**
		 * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
		 * the current viewport.
		 *
		 * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
		 *
		 * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
		 *
		 * @type {boolean}
		 */
		assumeViewportIndependence: true
	};

	/**
	 * Resizes the given elements.
	 *
	 * @param {HTMLElement[]} elements
	 */
	function resizeElements(elements) {
		elements = elements.filter(function (e) {
			var codeStyles = getStyles(e);
			var whiteSpace = codeStyles['white-space'];
			return whiteSpace === 'pre-wrap' || whiteSpace === 'pre-line';
		});

		if (elements.length == 0) {
			return;
		}

		var infos = elements.map(function (element) {
			var codeElement = element.querySelector('pre');
			var lineNumbersWrapper = element.querySelector('.line-numbers-rows');
			if (!codeElement || !lineNumbersWrapper) {
				return undefined;
			}

			/** @type {HTMLElement} */
			var lineNumberSizer = element.querySelector('.line-numbers-sizer');
			var codeLines = codeElement.textContent.split(NEW_LINE_EXP);

			if (!lineNumberSizer) {
				lineNumberSizer = document.createElement('span');
				lineNumberSizer.className = 'line-numbers-sizer';

				codeElement.appendChild(lineNumberSizer);
			}

			lineNumberSizer.innerHTML = '0';
			lineNumberSizer.style.display = 'block';

			var oneLinerHeight = lineNumberSizer.getBoundingClientRect().height;
			lineNumberSizer.innerHTML = '';

			return {
				element: element,
				lines: codeLines,
				lineHeights: [],
				oneLinerHeight: oneLinerHeight,
				sizer: lineNumberSizer,
			};
		}).filter(Boolean);

		infos.forEach(function (info) {
			var lineNumberSizer = info.sizer;
			var lines = info.lines;
			var lineHeights = info.lineHeights;
			var oneLinerHeight = info.oneLinerHeight;

			lineHeights[lines.length - 1] = undefined;
			lines.forEach(function (line, index) {
				if (line && line.length > 1) {
					var e = lineNumberSizer.appendChild(document.createElement('span'));
					e.style.display = 'block';
					e.textContent = line;
				} else {
					lineHeights[index] = oneLinerHeight;
				}
			});
		});

		infos.forEach(function (info) {
			var lineNumberSizer = info.sizer;
			var lineHeights = info.lineHeights;

			var childIndex = 0;
			for (var i = 0; i < lineHeights.length; i++) {
				if (lineHeights[i] === undefined) {
					lineHeights[i] = lineNumberSizer.children[childIndex++].getBoundingClientRect().height;
				}
			}
		});

		infos.forEach(function (info) {
			var lineNumberSizer = info.sizer;
			var wrapper = info.element.querySelector('.line-numbers-rows');

			lineNumberSizer.style.display = 'none';
			lineNumberSizer.innerHTML = '';

			info.lineHeights.forEach(function (height, lineNumber) {
				wrapper.children[lineNumber].style.height = height + 'px';
			});
		});
	}

	/**
	 * Returns style declarations for the element
	 *
	 * @param {Element} element
	 */
	function getStyles(element) {
		if (!element) {
			return null;
		}

		return window.getComputedStyle ? getComputedStyle(element) : (element.currentStyle || null);
	}

	var lastWidth = undefined;
	window.addEventListener('resize', function () {
		if (config.assumeViewportIndependence && lastWidth === window.innerWidth) {
			return;
		}
		lastWidth = window.innerWidth;

		resizeElements(Array.prototype.slice.call(document.querySelectorAll('pre.' + PLUGIN_NAME)));
	});

	Prism.hooks.add('complete', function (env) {
		if (!env.code) {
			return;
		}

		var code = /** @type {Element} */ (env.element);
		var pre = /** @type {HTMLElement} */ (code.parentNode);

		// works only for <code> wrapped inside <pre> (not inline)
		if (!pre || !/pre/i.test(pre.nodeName)) {
			return;
		}

		// Abort if line numbers already exists
		if (code.querySelector('.line-numbers-rows')) {
			return;
		}

		// only add line numbers if <code> or one of its ancestors has the `line-numbers` class
		if (!Prism.util.isActive(code, PLUGIN_NAME)) {
			return;
		}

		// Remove the class 'line-numbers' from the <code>
		code.classList.remove(PLUGIN_NAME);
		// Add the class 'line-numbers' to the <pre>
		pre.classList.add(PLUGIN_NAME);

		var match = env.code.match(NEW_LINE_EXP);
		var linesNum = match ? match.length + 1 : 1;
		var lineNumbersWrapper;

		var lines = new Array(linesNum + 1).join('<span></span>');

		lineNumbersWrapper = document.createElement('span');
		lineNumbersWrapper.setAttribute('aria-hidden', 'true');
		lineNumbersWrapper.className = 'line-numbers-rows';
		lineNumbersWrapper.innerHTML = lines;

		if (pre.hasAttribute('data-start')) {
			pre.style.counterReset = 'linenumber ' + (parseInt(pre.getAttribute('data-start'), 10) - 1);
		}

		env.element.appendChild(lineNumbersWrapper);

		resizeElements([pre]);

		Prism.hooks.run('line-numbers', env);
	});

	Prism.hooks.add('line-numbers', function (env) {
		env.plugins = env.plugins || {};
		env.plugins.lineNumbers = true;
	});

}());


    </script>
</body>
</html>
